# nfactorial API Redesign - Implementation Notes

This document tracks implementation progress, decisions, and user feedback for the multi-phase API redesign proposed in `NEW_DESIGN.md`.

## Purpose

- Keep a running log of what was implemented and why
- Track what is working, what is not, and what needs follow-up
- Capture user preferences/feedback during iteration

## User Preferences and Feedback

- 2026-02-15: User approved the phased migration plan.
- 2026-02-15: User requested we start with Phase 0.
- 2026-02-15: User requested a persistent root-level markdown tracker for progress and notes.
- 2026-02-15: User requested old tool interfaces remain compatibility-only while all new/internal paths use canonical `tool` + `ToolResult` APIs.
- 2026-02-15: User requested high-signal tests only (avoid low-value/bloat assertions).

## Phase Tracker

- [~] Phase 0 - Safety net and compatibility lock (unit lock complete, more integration/e2e guardrails pending)
- [x] Phase 1 - Public API scaffolding (`tool`, `hook`, `wait`)
- [x] Phase 2 - Signature compiler and dependency inference
- [x] Phase 3 - Hook persistence and control-plane resolution APIs
- [x] Phase 4 - Worker hook runtime and staged continuation
- [ ] Phase 5 - Wait helpers (`sleep`, `cron`, `children`)
- [ ] Phase 6 - Managed endpoints, docs, migration utilities

## Progress Log

### 2026-02-15

- Completed deep review of:
  - runtime (`agent`, `orchestrator`, `queue`, `lua`)
  - current public DX and examples
  - unit/integration/e2e test coverage
  - full proposal in `NEW_DESIGN.md`
- Confirmed current pending/resume machinery is a strong base for hook sessions.
- Started Phase 0 implementation:
  - creating regression tests for current tool/deferred/forking behavior
  - no production runtime behavior changes planned in this phase
- Added Phase 0 regression test file:
  - `tests/unit/test_tools_phase0_regression.py`
  - Covers:
    - `function_tool` schema/description behavior
    - strict schema behavior for optional params
    - context param exclusion in tool schema
    - `convert_tools_list` mixed inputs
    - `forking_tool` wrappers
    - `Agent.tool_action` deferred and forking semantics
    - invalid forking child ID validation
- Validation status:
  - lints: clean for new files
  - syntax: `python -m py_compile tests/unit/test_tools_phase0_regression.py` passed
  - unit tests:
    - command: `source .venv/bin/activate && pytest tests/unit/test_tools_phase0_regression.py -q`
    - result: `10 passed`
  - noted environment detail:
    - in this environment, direct `pytest` from project `.venv` works reliably
    - `uv run` may fail under sandbox/cache permission constraints
- Started and completed Phase 1 scaffolding (no runtime semantics changes yet):
  - Added `src/factorial/hooks.py`:
    - `Hook`
    - `PendingHook[T]`
    - `HookRequestContext`
    - `HookDependency`
    - `hook.requires(...)` and `hook.awaits(...)`
  - Added `src/factorial/waits.py`:
    - `WaitInstruction`
    - `wait.sleep(...)`
    - `wait.cron(...)`
    - `wait.children(...)`
  - Extended `src/factorial/tools.py`:
    - `ToolResult`
    - `ToolNamespace`
    - `tool(...)` decorator alias + `tool.ok/fail/error`
  - Updated `src/factorial/__init__.py` exports for new API surface.
  - Added `tests/unit/test_phase1_api_scaffolding.py`:
    - namespace decorator behavior
    - tool result constructors
    - typed hook pending ticket helpers
    - hook dependency metadata
    - wait instruction builders
- Refined `src/factorial/tools.py` toward new-primary API style:
  - `ToolResult` is now the canonical result model
  - legacy `FunctionToolActionResult` kept as a compatibility alias to `ToolResult`
  - introduced canonical `ToolAction*` type aliases with legacy aliases preserved
  - `function_tool` now explicitly documented/implemented as a legacy alias path
  - conversion helpers now route callable conversion through the primary `tool(...)` interface
- Further canonicalization pass for tool internals:
  - introduced canonical `ToolDefinition` class
  - `FunctionTool` is now a compatibility alias (`FunctionTool = ToolDefinition`)
  - internal factory and conversion paths now construct/use `ToolDefinition`, not `FunctionTool`
  - `function_tool(...)` now emits a `DeprecationWarning` and remains compatibility-only
  - `agent.py` internal typing switched to canonical names (`ToolDefinition`, `ToolResult`)
  - removed remaining old-path typing/wording references in `tools.py` internals
- Current unit validation after Phase 1:
  - command:
    - `source .venv/bin/activate && pytest tests/unit/test_tools_phase0_regression.py tests/unit/test_phase1_api_scaffolding.py -q`
  - result: `16 passed`
- Started and completed Phase 2 compiler/inference work:
  - Expanded `src/factorial/hooks.py` with compiler/runtime metadata:
    - `HookNodeSpec` and `HookExecutionPlan`
    - `compile_hook_plan(...)`
    - compile-time error types:
      - `HookCompilationError`
      - `HookDependencyResolutionError`
      - `HookTypeMismatchError`
      - `HookDependencyCycleError`
  - Compiler behavior now validates and infers:
    - hook parameters declared as `Annotated[HookType, hook.requires/awaits(...)]`
    - request-builder injections from:
      - `ctx: HookRequestContext`
      - tool args by name
      - previously resolved hook payload params by name
      - optional/defaulted request-builder params
    - type compatibility for referenced hook params
    - request-builder return annotation compatibility with `PendingHook[...]`
    - cycle detection and deterministic staged ordering
  - Wired compiler into canonical tool registration path in `src/factorial/tools.py`:
    - `ToolDefinition` now carries optional `hook_plan`
    - `_tool_factory(...)` now compiles hook plans at registration time (fail-fast startup behavior)
    - `_function_to_json_schema(...)` now excludes hook payload params from exposed tool JSON schema
  - Added unit tests in `tests/unit/test_phase2_hook_compiler.py` covering:
    - dependency inference and stage ordering
    - parallel stage grouping for independent hooks
    - hook param exclusion from JSON schema
    - unresolved dependency failures
    - type-only reference failures (enforce name-based hook wiring)
    - reference type mismatch failures
    - request-builder return type mismatch failures
    - cycle detection failures
    - optional/default dependency allowance
- Current unit validation after Phase 2:
  - command:
    - `source .venv/bin/activate && pytest tests/unit/test_tools_phase0_regression.py tests/unit/test_phase1_api_scaffolding.py tests/unit/test_phase2_hook_compiler.py -q`
  - result: `25 passed`
- Started and completed Phase 3 hook persistence/control-plane foundation:
  - Added new hook control-plane exceptions in `src/factorial/exceptions.py`:
    - `HookNotFoundError`
    - `HookTokenValidationError`
    - `HookExpiredError`
    - `HookAlreadyResolvedError`
  - Added `HookResolutionResult` in `src/factorial/hooks.py`.
  - Extended queue operations in `src/factorial/queue/operations.py` with:
    - `register_pending_hook(...)`
    - `resolve_hook(...)`
    - `rotate_hook_token(...)`
  - Persistence/runtime details now implemented:
    - hook records stored under namespace-scoped hook index
    - per-task hook index and expiry zset bookkeeping
    - token hashing via SHA-256 (plaintext token never persisted)
    - token validation with constant-time comparison
    - idempotency key handling for repeated external callbacks
    - resolved payload persistence and wake/requeue integration with pending tool state
  - Added orchestrator wrappers in `src/factorial/orchestrator.py`:
    - `Orchestrator.register_pending_hook(...)`
    - `Orchestrator.resolve_hook(...)`
    - `Orchestrator.rotate_hook_token(...)`
  - Export updates:
    - `factorial.queue` now exports hook control-plane queue ops
    - package root export includes `HookResolutionResult`
  - Added integration tests in `tests/integration/test_hooks_phase3.py` covering:
    - hook registration + persisted token hash behavior
    - valid token resolution and task requeue
    - invalid token rejection
    - idempotent replay behavior
    - token rotation with previous-token invalidation
- Current validation after Phase 3:
  - command:
    - `source .venv/bin/activate && pytest tests/unit tests/integration/test_pending.py tests/integration/test_hooks_phase3.py -q`
  - result: `100 passed`
- Follow-up hardening focused on state-machine/Lua interaction quality:
  - Completed a queue/Lua transition audit for hook flow and confirmed:
    - hook path reuses existing `pending_tool_results` + `queue_pending` + `tool_completion.lua`
    - no new task statuses introduced in this phase
  - Added runtime guard in `register_pending_hook(...)`:
    - registration now requires task status in `processing | pending_tool_results`
    - supports first-stage hook registration during tool execution while still blocking terminal/invalid states
  - Updated hook resolution wake logic for multi-hook tool calls:
    - `resolve_hook(...)` now checks all hooks linked to the same `task_id + tool_call_id`
    - task wake/requeue only happens when all such hooks are resolved
    - prevents premature resume when a single tool call has multiple hook dependencies
  - Added high-signal integration assertions (no string-bloat checks):
    - successful hook resolve must:
      - move task from `queue_pending` to `queue_main`
      - set status to `active`
      - delete `pending_tool_results` hash
      - persist resolved hook payload and remove hook from expiry zset
    - idempotent replay must not create duplicate requeue
    - expired hook resolve must not requeue task and must keep task parked
    - registration from non-pending states must fail fast
    - multi-hook same-tool-call must not resume on first hook resolution
  - Added naming-alignment comments only (no risky state renames yet):
    - `queue_pending` documented as parked queue for external tool/hook/child waits
    - `pending_tool_results` documented as including hook-backed deferred completions
    - `completion.lua` comment clarifies pending branch trigger is `pending_*_ids_json` presence, not action string
- Current validation after follow-up hardening:
  - command:
    - `source .venv/bin/activate && pytest tests/unit tests/integration/test_pending.py tests/integration/test_hooks_phase3.py -q`
  - result: `79 passed`
- Started Phase 4 staged hook runtime implementation:
  - Added persisted session runtime types in `src/factorial/hooks.py`:
    - `HookSessionNode`
    - `HookSessionRecord`
    - `build_request_builder_kwargs(...)` runtime DI helper
  - Extended hook record shape (`HookRecord`) to carry runtime linkage metadata:
    - `tool_name`, `tool_args`
    - `hook_param_name`, `depends_on`
    - `session_id` used for DAG session correlation
  - Added session keys in `src/factorial/queue/keys.py`:
    - `hook_sessions`
    - `hook_session_by_tool_call`
    - `hook_sessions_by_task`
  - Added execution-context callback path for runtime persistence:
    - `ExecutionContext.persist_hook_runtime`
    - `ExecutionContext.persist_hook_session(...)`
    - worker now wires callback to `persist_hook_runtime_payload(...)`
  - Implemented hook-enabled tool first-pass behavior in `BaseAgent.tool_action(...)`:
    - when a tool has `hook_plan` and no hook payloads are present:
      - build and persist a hook session
      - request first stage hooks
      - register pending hook records
      - return pending tool result to park task
    - when hook payloads are present, continuation executes normal tool body
  - Implemented staged resolution flow in `resolve_hook(...)`:
    - resolve current node + persist payload
    - request next ready stage when dependencies become satisfied
    - execute final tool continuation only after all session nodes resolve
    - complete tool slot via existing pending-tool wake/requeue primitives
  - Added high-signal integration coverage in `tests/integration/test_hooks_phase3.py`:
    - `test_dag_stage_progression_and_final_continuation`
    - validates stage-1 request, stage-2 unlock, final continuation execution, and proper task wake/requeue
- Current validation after Phase 4 increment:
  - command:
    - `source .venv/bin/activate && pytest tests/unit/test_phase1_api_scaffolding.py tests/unit/test_phase2_hook_compiler.py tests/unit/test_tools_phase0_regression.py tests/integration/test_hooks_phase3.py`
  - result: `34 passed`
- Completed Phase 4 robustness hardening after deep state-machine/Lua audit:
  - Key architectural correction:
    - moved DAG stage progression and tool continuation execution out of control-plane `resolve_hook(...)`
    - control plane now performs state transition + atomic wake signaling only
    - worker now owns request-next-stage and execute-final-continuation runtime behavior
  - Added atomic wake path for hook sessions:
    - new Lua script `src/factorial/queue/lua/hook_wake.lua`
    - new loader API `create_hook_wake_script(...)`
    - new per-task key `hook_runtime_ready` to persist worker tick intents
    - wake script atomically:
      - records wake intent
      - transitions task `pending_tool_results -> active`
      - moves task from `queue_pending -> queue_main`
  - Strengthened hook-session persistence robustness:
    - `persist_hook_runtime_payload(...)` now persists session + initial hook records in one Redis transaction
    - avoids split-brain windows between session metadata and hook registry entries
    - idempotent replay guard on `hook_session_by_tool_call`
  - Added worker runtime hook tick engine:
    - `process_hook_runtime_wake_requests(...)` in queue ops
    - worker now processes hook wake requests before calling `agent.execute(...)`
    - worker behavior on wake:
      - request next stage when dependencies are ready, then re-park task atomically via existing completion Lua path
      - execute final tool continuation only when all session nodes are resolved
      - apply deferred tool result into task context, then continue normal turn execution
  - Added idempotency hardening for callbacks:
    - deterministic hook session id derived from `(task_id, tool_call_id, tool_name)` in `BaseAgent.tool_action(...)`
    - deterministic hook ids per node (`{session_id}:{param_name}`) to improve replay safety
    - `resolve_hook(...)` now supports idempotent replay with idempotency keys even if hook is already resolved, and can still emit wake intent
  - Updated high-signal integration coverage:
    - `test_dag_stage_progression_and_final_continuation` now validates true worker-plane progression:
      - resolve stage 1 -> atomic wake
      - worker tick requests stage 2 -> re-park
      - resolve stage 2 -> atomic wake
      - worker tick executes final continuation and yields completed tool result
- Current validation after Phase 4 completion:
  - command:
    - `source .venv/bin/activate && pytest`
  - result: `179 passed`
- Legacy pending-tool path sunset cleanup (post-Phase 4):
  - Removed the legacy deferred-tool decorator and runtime handling from public/core APIs.
  - Removed control-plane deferred completion API surface and fallback non-session completion branch.
  - `resolve_hook(...)` now requires session-backed hook records; non-session legacy completion is rejected.
  - Updated regression and integration tests to cover session-backed hook behavior only.
  - Migrated `examples/code_agent` runtime usage to hook-based approval + `resolve_hook` endpoint.
- Current validation after legacy-path removal:
  - command:
    - `source .venv/bin/activate && pytest`
  - result: `177 passed`
- Example runtime upgrade (`examples/code_agent`):
  - `request_code_execution` now executes code server-side in Vercel Sandbox.
  - UI no longer executes code in-browser; it resolves hook approvals via `/api/resolve_hook`.
  - Hook pending metadata (`requested_hooks`) is now included in pending tool progress output so the example UI can drive approval/rejection flows.
  - Added `vercel-sandbox` dependency and Docker env passthrough for Vercel credentials.
- Current validation after example/runtime update:
  - command:
    - `source .venv/bin/activate && pytest`
  - result: `177 passed`

## Decisions

- Preserve existing queue/Lua reliability semantics and build hook runtime on top.
- Keep backward compatibility while introducing the new API surface.
- Treat tests as the migration contract before introducing runtime changes.
- For iterative testing, use project virtualenv activation + `pytest` directly.

## Open Questions (Tracking)

- Naming strategy for pending wait APIs vs existing `pending_tool_results` internals.
- Managed vs BYO endpoint defaults in docs and examples.

## Next Step

- Start Phase 5: wait helpers runtime (`sleep`, `cron`, `children`) with the same Lua/atomic state-machine standards and high-signal tests.
